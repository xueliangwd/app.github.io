<img src="https://raw.githubusercontent.com/xueliangwd/leon/main/images/blog_header.jpg" alt="" title="">

<h1>日视图效果算法实现</h1>
<img src="https://raw.githubusercontent.com/xueliangwd/leon/main/images/schedule_day.jpg" alt="" title="">

<p>实现如上图中，类似钉钉、飞书中日历日视图效果；</p>
<h3>效果分析：</h3>
<p>在y轴上高度代表时间间隔，在x轴上有时间交叉的日程进行宽度等分；
    一个日程能与多个日程产生时间交叉，所以我们不能用线性结构处理，这样我们就考虑用树或图结构；
    一个日程交叉点会大于2个，这里采用多叉树（如果不太好理解，枚举较全面的效果，顺时针转90度看效果图也很像一个树结构）；</p>
<h4>定义一个树节点的Node，ScheduleNode：</h4>
<pre><code class="language-dart">ScheduleNode? parent;
  List&lt;ScheduleNode&gt;? children;
  double x = 0; // UI中x轴位置 positionX = x*WidgetWidth
  int? beginTime; // 时间戳 开始时间在UI中计算y位置
  int startMinute; // 相对00：00开始的分钟
  int duration;  // 分钟
  double weight = 1;//UI中宽度权重 width=weight*WidgetWidth
  String? title;
  // 同一时间的任务用link连接起来
  int level = 1;//层级,用于计算作为父节点时应该平分多少宽度
</code></pre>
<h4>日程时间是否有重叠</h4>
<pre><code class="language-dart"> bool isTaskOverlap(ScheduleNode taskB) {
    ScheduleNode taskA = this;
        if (taskA == taskB) return false;
        int taskAStart = taskA.getStartMinute();
        int taskAEnd = taskAStart + taskA.getDuration();
        int taskBStart = taskB.getStartMinute();
        int taskBEnd = taskBStart + taskB.getDuration();
        if (taskBStart &gt; taskAStart &amp;&amp; taskBStart &lt; taskAEnd ||
            taskBEnd &gt; taskAStart &amp;&amp; taskBStart &lt; taskAEnd ||
            taskBStart == taskAStart &amp;&amp; taskBStart == taskAEnd ) {
          return true;
        } else {
          return false;
        }
   }
</code></pre>
<h4>获取最深层的日程：</h4>
<pre><code class="language-dart">ScheduleNode getRearItem(ScheduleNode maxItem) {
    ScheduleNode p = this;
    ScheduleNode q = maxItem;
    if(p.children != null&amp;&amp; (p.children?.length??0)&gt;0){
        for(ScheduleNode child in p.children!){
            q = child.getRearItem(q);
        }
    }else{
        q = p;
    }
    return q.level &gt; maxItem.level?q:maxItem;
}
</code></pre>
<h4>设置Schedule所占宽度权重：</h4>
<pre><code class="language-dart">    void setLinkWeight() {
        ScheduleNode p = this;
        ScheduleNode maxTask = getRearItem(p);
        if(p.parent == null){
                p.weight = 1.0/maxTask.level;
        }else{
                p.x = p.parent!.x + p.parent!.weight;
                p.weight = (1.0 - p.x )/(maxTask.level - p.level + 1);
        }
        if(p.children != null){
            for(ScheduleNode child in p.children!){
                child.setLinkWeight();
            }
        }
}
</code></pre>
<h4>核心排练日程的位置计算规则</h4>
<pre><code class="language-dart">List&lt;ScheduleNode&gt; _arrangeTaskDataNew(List&lt;ScheduleNode&gt; tasks) {
    //按日程时间排序
    tasks.sort((ScheduleNode left, ScheduleNode right) {
    if (left.getDuration() == right.getDuration()) {
        return  left.getStartMinute().compareTo(right.getStartMinute());
    } else {
        return  - left.getDuration().compareTo(right.getDuration());
    }
    });
    //遍历将有时间重叠的日程关联分组
    for (int i = 0; i &lt; tasks.length; i++) {
        ScheduleNode taskA = tasks[i];
        for (int j = i + 1; j &lt; tasks.length; j++) {
            if (tasks[i].isTaskOverlap(tasks[j])) {
                ScheduleNode taskB = tasks[j];
                if(taskB.parent ==null){
                    taskB.level = taskA.level +1;
                    taskB.parent = taskA;
                    taskA.children == null?taskA.children = [taskB]:taskA.children!.add(taskB);
                }else if(taskB.level &lt; taskA.level +1){
                    taskB.parent!.children!.remove(taskB);
                    taskB.level = taskA.level +1;
                    taskB.parent = taskA;
                    taskA.children == null?taskA.children = [taskB]:taskA.children!.add(taskB);
                }
            }
        }
    }
//同行日程数过多 拆分  完全相同时间优化
// for (int i = 0; i &lt; tasks.length; i++) {
//   ScheduleNode taskA = tasks[i];
//   if(taskA.level &gt; 7){
//     //寻找拆分的父节点
//     ScheduleNode taskB = taskA.getSplitItem();
//     if(taskB != null){
//       //重设该节点层级
//       ScheduleNode parent = taskB.getInsertParentItem(taskB);
//       taskB.parent.children.remove(taskB);
//       taskB.parent = parent;
//       taskB.level = parent != null?parent.level+1:1;
//       taskB.setLinkLevel();
//     }
//   }
// }
    //标记日程链宽度位置
    for (int i = 0; i &lt; tasks.length; i++) {
        ScheduleNode taskA = tasks[i];
        if(taskA.parent == null){
            // // 获取最长层级
            // ScheduleNode maxTask = taskA.getRearItem(taskA);
            //根据最长层级，计算宽度和位置
            taskA.setLinkWeight();
        }
    }
    return tasks;
}
</code></pre>
<h4>整体排序：</h4>
<pre><code class="language-dart">List&lt;ScheduleNode&gt; arrangeTaskData(List&lt;ScheduleNode&gt; taskList) {
    List&lt;ScheduleNode&gt; tasks = _arrangeTaskDataNew(taskList);
    for (final task in tasks) {
        if (task.x + task.weight &gt; 1) {
            if (task.x &lt; 1) {
                task.weight = 1  - task.x;
            } else {
                task.x = 0;
                task.weight = 1;
            }
        }
    }
    return tasks;
}
</code></pre>

# App优化之路

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [App优化之路](#app优化之路)
  - [包体积优化](#包体积优化)
  - [启动优化](#启动优化)
  - [CPU优化](#cpu优化)
  - [UI卡顿（GPU）优化](#ui卡顿gpu优化)
  - [耗电量优化](#耗电量优化)

<!-- /code_chunk_output -->



##  包体积优化
- 资源瘦身，（LSUnusedResources）移除无用图片和类，压缩图片资源（ImageOptim）或使用webp格式
- 代码瘦身，LinkMap 结合 Mach-O删除无用代码，删除版本遗留代码，精简重复代码（PMD）
- 优化编译项，开启Bitcode，去掉 armv7及之前的架构，Generate Debug Symbols、Deployment Postprocessing在 release 下都设置为 Yes
- 移除 Framework 的未使用代码，动态库代替静态库，不要引用同功能三方库
## 启动优化
- 减少自定义动态库个数，苹果官方建议 自定义动态库 不超过6个
- 减少项目中未使用的类和方法
- 使用二进制重排将启动时需要的符号方法提前加载到内存，通过 Link Map 查看加载顺序，优化Build Setting --> Order File自定义加载顺序

## CPU优化
- 尽量要用轻量级对象，比如用不到事件处理的地方，可以考虑用CALayer来代替UIView

- 尽量不要频繁的调用UIView的相关属性，比如frame、transform、bouds等属性，尽量减少不必要的修改，降低CPU对View大小重新计算的频率

- 尽量提前计算好布局，在有需要的时一次性调整对应的属性，不要多次修改属性

- autolayout会比直接设置frame消耗更多的CPU资源，能用frame就不用autolayout

- 图片的size最好和UIImageView的size保持一致，减少CPU的计算

- 控制线程的最大并发数量

- 尽量把耗时的操作放在子线程处理：文本处理（尺寸的计算以及绘制）、图片处理（编码和绘制）
## UI卡顿（GPU）优化

- 避免使用 透明UIView
- 尽量使用PNG图片
- 避免离屏渲染（圆角使用贝塞尔曲线等）
- 预排版，常规的在Model层请求数据后提前将cell高度算好
- 尽量避免短时间内大量图片显示，尽可能的讲多张图片合并成一张来显示
- 创建图片预编码 / 解码，在子线程先将图片绘制到CGBitmapContext，然后从Bitmap中创建图片
- GPU能处理的最大纹理尺寸是4096 * 4096,一旦超过这个尺寸就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸
- 列表按需加载，只加载目标滚动范围行数（上下预留3行）
- 异步渲染，在子线程把需要绘制的图形提前处理好


## 耗电量优化

1.降低CPU使用率：
- 减少主线程的工作量：尽量把复杂的计算、网络请求等耗时操作放到后台线程中进行，避免在主线程中进行大量的计算和IO操作，以减少CPU的使用率。
- 使用合适的数据结构和算法：选择合适的数据结构和算法可以减少CPU的计算量，提高程序的运行效率，从而减少能耗。
- 减少循环的次数：循环操作是CPU消耗资源的重要原因之一，尽量减少循环次数，优化循环体内的操作，以减少CPU的使用率。

2.优化网络请求：
- 减少网络请求次数：网络请求是比较耗电的操作，尽量减少不必要的网络请求，合并多个请求，避免频繁的网络通信。
- 使用适当的缓存策略：合理使用网络缓存可以减小网络请求的次数，减少耗电量。
- 使用低功耗的网络传输方式：在适当的情况下，选择低功耗的网络传输方式，如使用低功耗蓝牙或近场通信等，可以减少电量的消耗。

3.优化图像显示：
- 使用合适的图像格式：选择合适的图像格式可以减少图像文件的大小，从而减少读取和解码的时间，减少CPU的使用率。
- 合理利用图像缓存：图像缓存可以减少重复的解码和渲染操作，减小CPU和GPU的使用率，从而减少能耗。

4.增量更新和增量同步：
- 在需要更新或同步数据时，尽量只传输和处理发生变化的部分，避免全量更新和同步，可以减少数据传输量和处理时间，从而减少能耗。

5.合理使用后台模式：
- 合理使用应用程序的后台模式，避免不必要的后台运行，可以减少电量的消耗。
- 在后台模式下，尽量减少CPU、网络和GPS等资源的使用，以降低电量的消耗。
